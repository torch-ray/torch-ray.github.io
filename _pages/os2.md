---
title: "운영체재 개요(2)"
sidebar:
  nav: "docs"
permalink: /docs/os/2/
layout: single
---

## CPU 스케줄링

- 체크포인트1: 일반적으로 대부분 프로그램은 CPU를 사용하고 I/O를 입력받고의 과정을 반복한다.
- 체크포인트2: 프로그램 동작 시간은 이해를 돕기 위해 초단위로 제시하였다.

여러 프로그램들이 CPU를 사용하기 위해 CPU큐에서 기다릴 때, 어떤 프로그램에게 CPU 사용권을 줄지 정하는 것이 운영체제의 역할 중 하나다. 동일한 시간에 간발의 차로 프로그램 1~3이 P1(24s), P2(3s), P3(3s) 순서로 CPU 큐에 들어왔다고 가정하면, First Come First Served에 따라 먼저 들어온 P1이 CPU를 24초 사용하고 I/O로 떠나고, 그다음 P2, P3 순서로 진행된다. 이러한 처리과정은 공평한듯 보이지만 효율적이지는 않다. P1은 기다린시간이 0초지만, P2는 24초, P3는 27초를 기다린 것이되고 총 기다린 시간의 평균은 17초이다.

이러한 문제점을 해결하기 위한 방법이 Shortest Job First로, CPU 사용 시간이 가장 적은 프로그램에게 우선순위를 주는 방법이다. 예를들면 P2, P3, P1순서로 처리하게 되면 동일한 프로그램을 3개처리한 것이지만, 대기시간은 0초, 3초, 6초로 총 대기시간의 평균을 내보면 3초가 된다. 앞서 사용했던 FCFS방법보다 무려 14초를 앞당길 수 있다. SJF 방식은 최저 평균 대기시간을 보장한다. 다만 이러한 처리 방식은 반대로 형평성의 문제가 생긴다. P1같이 처리시간이 긴 프로그램이 자신의 차례를 기다리다 또 다른 처리시간이 짧은 P4, P5가 오면 순서를 양보해야 하기 때문이다. 그렇게 되면 처리시간이 긴 프로그램은 영원히 처리되지도 못할 수 있는 Starvation 문제가 발생할 수 있다.

앞선 문제점들을 해결하기 위해 현재 CPU가 가장 많이 사용하고 있는 방법이 Round Robin이다. RR은 상기 언급했던 두 방식과는 다르게 운영체제가 하드웨어적 지원을 받아 프로세스에 인터럽트를 발생시켜서 CPU 사용권을 빼앗아온다. 쉽게 설명하자면 RR방식에는 최대로 CPU를 사용할 수 있는 시간이 정해져있다. RR을 20초라고 가정하고 P1(39s), P2(17s), p3(21s)와 같이 프로그램 3개가 CPU 큐에 들어왔다면, P1은 20초를 사용하고 CPU 큐 맨 뒤로가서 다시 줄을서게되고, P2는 모든 작업을 처리하고 I/O로 이동한다. P3는 20초를 사용하고 CPU 큐 맨뒤로 가게되고 이제 다시 P1, P3순서로 작업이 완료되고 I/O로 이동하게 되는 것이다. RR은 CPU를 사용하고자 하는 처리시간에 비례해서 대기시간을 갖게되기 때문에 효율적이고 공정한 방식으로 작동한다. RR방식은 어떠한 프로세스도 [(n-1) * 할당시간] 이상 기다리지 않을 수 있다.

## 메모리관리

- 체크포인트1: 디스크(파일시스템)는 전원이 off되더라도 파일이 저장되어 있는 공간이다.
- 체크포인트2: 메모리에서 쪼개지는 단위를 [페이지](https://ko.wikipedia.org/wiki/%ED%8E%98%EC%9D%B4%EC%A7%95)라고 한다.

디스크에 실행파일이 저장되어 있고, 휘발성 기억장치인 메모리는 비어있다. 컴퓨터의 전원을 켜면 메모리에 운영체제가 올라가게되고, 디스크(파일시스템)의 실행파일A, 실행파일B를 작동시키면 메모리에 프로세스A, 프로세스B로 올가게된다. 이 과정이 일반적으로 우리가 알고 있는 프로그램의 작동과정인데, 사실 실행파일은 바로 메모리에 프로세스로 올라가는 것이 아니고 먼저 가상메모리에 올라가게 된다. 그리고 가상메모리에서 실제로 사용이 필요한 부분만 물리적인 메모리로 이동하여 처리가 된다. 그렇게 하지 않고 바로 물리적인 메모리로 프로그램을 올리게 된다면 사용하지도 않을 부분이 메모리를 차지하여 메모리를 낭비할 수도 있게되기 때문이다. 이 때 메모리의 사용량이 가득차게 되면 메모리를 차지하고 있는 무언가를 쫓아내서 다시 디스크(스왑영역)로 보내게 된다. 디스크(스왑영역은)는 메모리의 연장공간으로, 일단은 디스크이기 때문에 전원이 꺼지더라도 정보가 저장이 되겠지만 프로세스, 메모리는 전원이 꺼지면 모든 정보가 날라가기 때문에 디스크(스왑영역)의 정보들은 의미없는 정보가 된다.

그렇다면 가득차있는 메모리에 추가 정보가 들어왔을 때, 어떤 페이지를 쫓아내는 것일까? CPU가 요청한 페이지 순서가 [1, 1, 1, 1, 2, 2, 3, 3, 2, 4, 5]라고 가정하고, 메모리는 [0, 0, 0, 0, 운영체제] 현재 4공간이 사용가능하다고 가정한다. 이때 CPU의 요청을 받고 운영체제는 디스크 컨트롤로에 요청하여 디스크로부터 1페이지를 메모리에 올린다 [1, 0, 0, 0, 운영체제]. 그 이후 1페이지 처리요청에 대해서는 메모리에 올라와있는 1페이지를 가져오면 되기 때문에 디스크에 요청해서 읽어올 필요가 없다. 2페이지를 요청하면 [1, 2, 0, 0, 운영체제] 디스크로부터 2페이지를 메모리로 올리고, 그 다음 3, 4를 올리면 [1, 2, 3, 4, 운영체제]와 같이 메모리가 가득차게 된다. 이제 5번을 메모리로 올리기 위해 운영체제는 메모리에서 어떤 페이지를 쫓아내야 할까? 기본적인 작동방식은 디스크로부터 페이지를 다시 메모리로 올리는 작업을 하지 않기 위해 앞으로 CPU가 요청하지 않을 것 같은 페이지를 쫓아내는 방식으로 작동한다.

문제는 그렇다면 미래에 어떤 페이지가 필요하지 않을지 알 수 있을까? 미래를 예측하는 방법은 과거를 살펴보고 예측하는 방법밖에 없다. 따라서 운영체제도 과거를 살펴보고 다시 사용되지 않을 것 같은 페이지를 쫓아낸다. 미래 예측 방식에는 LRU와 LFU가 있다. LRU는 가장 오래 전에 참조된 페이지를 삭제하는 방식이다. LRU 방식으로 메모리를 관리하면 1번 페이지를 쫓아낼 것이다. LRU는 최근에 사용된 페이지가 다시 사용될 확률이 높고, 가장 오래 전에 사용한 페이지가 다시 사용될 가능성이 낮다고 생각하고 작동한다. 반면에 LFU는 가장 적게 사용된 페이지를 쫓아낸다. 따라서 LFU는 4번을 삭제한다. LFU는 과거에 많이 사용된 페이지는 또 사용될 가능성이 높고, 적게 사용된 페이지는 다시 사용될 가능성이 낮다고 생각하고 작동하는 것이다.

어떤 방식이든 장단점이 있기 때문에, 현재에도 두 방식의 단점을 모두 극복하기 위한 메모리 관리 방식이 연구되고 있다.

## 디스크 스케줄링

- 체크포인트1: 디스크 작동시간 중 제일 많은 부분을 소요하는 것은 디스크 헤드의 이동시간이다.
- 체크포인트2: 디스크 접근 시간의 구성 (탐색시간, 회전지연, 전송시간)
- 체크포인트3: 탐색시간(Seek time)은 헤드를 해당 트랙으로 움직이는데 걸리는 시간
- 체크포인트4: 회전지연(Rotational latency)은 헤드가 원하는 섹터(특정 트랙의 내부 공간)에 도달하기까지 걸리는 시간
- 체크포인트5: 전송시간(Transfer time)은 실제 데이터의 전송시간

디스크는 여러 동심원으로 이루어져 있다. 가장 내부를 디스크 트랙 100번이라고 가정하고, 가장 밖에 있는 디스크 트랙은 1번이라고 가정해보자. 디스크 큐에 [1, 100, 3, 99, 2]와 같이 처리요청이 왔다면 디스크 헤드는 어떻게 작동하게 될까? 가장 밖에서 1번을 읽고 가장 안 쪽으로 들어가서 100번을 읽고 다시 밖으로 나와 3번을 읽는 과정이 반복되고 많은 시간이 소요될 것이다. 디스크의 데이터 처리 시간은 탐색시간, 회전시간, 전송시간 순서로 오래 걸린다. 따라서 디스크를 효율적으로 관리하기 위해서는 시간 순서대로 처리하는 것이 아니라 헤드의 이동거리(탐색시간)를 줄이는 방법으로 스케줄링을 해야한다.

이를 위해 디스크는 FCFS가 아닌, Shortest Seek Time First 방식을 사용해야 할 듯 보인다. 디스크 큐에 들어온 요청 중에 현재위치를 기준으로 가장 Seek time이 짧은 지를 탐색하고 그 요청부터 처리하는 방법이다. 하지만 이러한 방식도 CPU 스케줄링과 마찬가지로 Starvation문제가 발생할 수 있다. 그렇기 때문에 현재 디스크 스케줄링에서 가장 많이 사용되는 방법은 SCAN이다. 헤드는 요청과 관계없이 한쪽 끝에서 다른 끝쪽까지 반복적으로 이동한다. 그리고 가는 길목에 요청이 있다면 처리하는 방식이다. 이러한 방식은 특정 위치라서 차별(Starvation)을 받지도 않고 헤드의 이동거리도 짧다는 장점이 있다. Elevator의 작동 방식을 생각해보면 이해가 쉽다.
